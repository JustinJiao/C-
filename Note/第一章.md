# 第一章：
## 1.1编写一个简单的C++程序
每个C++程序都包含一个或多个函数，其中一个必须命名为main，操作系统通过调用main来运行C++程序。
一个函数的定义包含四部分内容：
1. 返回类型
2. 函数名
3. 行参列表
4. 函数体
main的返回值代表状态。返回值为0表明成功，非0的返回由系统定义，用餐用来指出错误类型。


## 1.2 输入输出
通常运用标准库：iostream
cin：输入（标准输入）
cout：输出（标准输出）
cerr：输出警告和错误信息（标准错误）
clog：输出程序运行时的一般性信息。

<<这个运算符接收两个运算对象，左侧的运算对象必须是一个ostream，右侧的对象是打印的值。将给定的值写到给定的ostream对象中。
”>>“同理
endl是操纵符的特殊值，写入endl的效果是结束当前行。并将与设备关联的缓冲区中的内容冲刷到设备中。

### 问题：不刷新缓冲区会比较高效，那么为什么要刷新缓冲区
    刷新缓冲区的主要目的是为了解决数据及时输出的问题，在某些情况下，不刷新
    可能看不到想要的输出。
    什么时候需要刷新：
    1. 立即要看到输出的时候，比如说请输入一个数字
    2. 实时日志输出，在日志系统或者调试信息里，我们希望每条日志都能立即
       写入文件/终端，而不是等到缓冲区满了才写。如果不刷新，可能日志延迟
       输出，甚至在程序崩溃时丢失。
    3.当程序向文件写入数据的时候，如果不刷新就会导致数据可能滞留在缓冲区，导致文件不完整
    4.避免长时间等待，假设有一个进度条，cout需要一行一行实时更新，如果不刷新就会在最后一刻才全部显示。

    不用的情况：
    1.普通输出
    2.一次性批量输出，比如写入文件

    std::flush不换行，但仍然会强制刷新缓冲区，把数据立即输出。
    缓冲区可以提高I/O的效率。就像是超市买东西，先把物品放到购物篮再一起结账。
    std::的作用是指出名cout和endl是定义在std命名空间中的（namespace）。
    命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。
    副作用就是比较麻烦，因为必须显氏的说我们想使用的名字
    ：：是作用域运算符来指出我们想使用定义在std中的名字cout
    如果不加std::那么编辑器就不知道cout是什么，就无法使用。这个有个好处就是
    如果你定义了一个int cout =1 你再使用std::cout是可以使用的。


## 1.3 注释简介
//和/**/两种方式

## 1.4 控制流
### for循环和 While循环的优缺点：
for循环：
优点：
适用于循环次数已知的情况，执行固定次数的任务
结构紧凑，所有控制变量（初始化，条件，更新）都集中在一行，代码清晰
避免了while可能遗漏更新变量从而禅师死循环的可能性
缺点：
不适用于循环次数不确定情况，比如基于用户输入或某个条件动态变化
可能会影响可读性，如果循环体较长，更新部分不容易被发现。

while循环：
优点：
适用于循环次数不确定的情况，比如等待某个条件成立、处理用户输入。
更灵活，控制变量的初始化和更新可以分布在循环内部，适合动态变化的逻辑。
缺点：
如果控制变量更新被遗漏，那么可能会导致死循环
结构较松散，控制变量的初始化和更新可能分布在循环外或循环内，不如for紧凑

1. i++和++i
i++是先返回原值然后再进行加一
eg:i = 5, a = i++. 此时a=5
如果是++i的话就是 a=6
++i在底层优化的时候会更快，因为i++会创建一个临时变量存储原值，然后再递增
而++i会直接修改
对于循环中没有影响

## 1.5 类
Sales_item item;
我们可以说这是一个Sales_item 对象，或一个Sales_item

当引用标准库文件的时候用<>包围头文件名。对于不属于标准库的头文件，则用双引号包围“”

我们可以调用成员函数。
item1.isbn()=item2.isbn()
此时isbn是成员函数，或者我们可以称为method。
我们通常以一个类对象的名义来调用成员函数。
item1.isbn()
使用点运算符. 来表达我们需要名为item1的对象的isbn成员。左侧必须是一个类对象，右侧必须是该对象的成员名。
在访问成员函数也就是method的时候，用()调用符号来进行调用。

📌 [查看 C++ 代码](../Code/第一章.cpp)
